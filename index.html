<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Le mie competenze lavorative</title>
    <link href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css" rel="stylesheet">
    <!-- Aggiungi il CSS di Prism.js per evidenziare la sintassi -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet" />
    <style>
        /* Sfondo della pagina e testo bianco */
        body {
            background-color: #000000; /* Imposta lo sfondo nero */
            color: #ffffff; /* Imposta il colore del testo bianco */
        }

        /* Applica il colore bianco a tutti gli altri elementi */
        h1, h2, h3, h4, h5, h6, li {
            color: #ffffff; /* Colore bianco per intestazioni, paragrafi e lista */
        }

        /* Colore grigio chiaro per il testo dei paragrafi */
        p {
            color: #a0a0a0; /* Colore grigio chiaro per i paragrafi */
        }

        .intro-container {
            text-align: center; /* Centra l'immagine e il testo orizzontalmente */
            margin-bottom: 100px; /* Spazio sotto il contenitore */
        }

        .intro-container img {
            display: block; /* Rimuove eventuali spazi extra sotto l'immagine */
            margin: 0 auto; /* Centra l'immagine orizzontalmente */
            width: 30%; /* Riduce la dimensione dell'immagine */
            height: auto; /* Mantiene le proporzioni dell'immagine */
            object-fit: contain; /* Adatta l'immagine senza tagliarla */
            border-radius: 8px; /* (Facoltativo) Smussa i bordi dell'immagine */
            margin-bottom: 40px; /* Aggiunge spazio tra l'immagine e il testo */
        }

        .intro-container h2 {
            margin-top: 40px; /* Aggiunge spazio sopra il titolo "Chi sono?" */
            margin-bottom: 20px;
            color: #FFCC00; /* Giallo simile a quello di Bloomberg */
        }

        /* Allinea il titolo "I miei progetti" al centro della pagina */
        h3 {
            text-align: center;
            color: #ffffff; /* Giallo simile a quello di Bloomberg */
            margin-top: 20px; /* Spazio sopra al titolo */
            margin-bottom: 20px; /* Spazio sotto il titolo */
        }

        /* Assicura che il contenuto dei progetti sia anche centrato */
        .project-container {
            text-align: center; /* Centra il contenuto dei progetti */
        }
/* Colore giallo per i titoli dei progetti */
        h4 {
            color: #FFCC00; /* Giallo simile a quello di Bloomberg */
        }
        .intro-container p {
            margin-top: 10px;
        }

        /* Apparenza del blocco di codice */
        pre {
            background-color: #333333; /* Sfondo scuro per il blocco di codice */
            color: #f1f1f1; /* Colore chiaro per il testo */
            padding: 10px;
            border-radius: 5px;
            white-space: pre-wrap; /* Rende il testo a capo automaticamente se necessario */
            word-wrap: break-word;
            font-family: monospace; /* Font a spaziatura fissa per il codice */
            margin-top: 20px; /* Distanza dal paragrafo precedente */
            max-height: 300px; /* Imposta un'altezza massima per la finestra */
            overflow: auto; /* Aggiunge la barra di scorrimento quando il contenuto √® troppo grande */
        }

        /* Apparenza dell'area di testo per l'inserimento del codice */
        textarea {
            width: 100%;
            height: 150px;
            background-color: #333333;
            color: #f1f1f1;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            border: none;
            margin-top: 20px;
        }

        .copy-btn {
            background-color: #333;
            color: #fff;
            border: none;
            padding: 10px 15px;
            font-size: 14px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
        }

        .copy-btn:hover {
            background-color: #555;
        }
        .download-btn {
            background-color: #FFCC00; /* Giallo simile a Bloomberg */
            color: #000000; /* Testo nero */
            border: none;
            padding: 8px 15px; /* Ridotto il padding per un bottone pi√π piccolo */
            font-size: 14px; /* Ridotto il font size */
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            text-decoration: none;
            display: inline-block;
            transition: background-color 0.3s ease-in-out;
            text-align: center; /* Allinea il testo al centro */
            max-width: 200px; /* Imposta la larghezza massima */
            width: auto; /* Imposta la larghezza automatica per adattarsi al contenuto */
            margin: 0 auto; /* Centra il bottone orizzontalmente */
        }

        .download-btn:hover {
            background-color: #e6b800; /* Tonalit√† leggermente pi√π scura al passaggio del mouse */
        }
        /* Aggiungi questa regola per centrare il bottone nel suo contenitore */
        section {
            text-align: center; /* Centra il contenuto del contenitore */
        }
    </style>
</head>    
<body>
    <main class="container">
        <section>
            <!-- Sezione di Introduzione -->
            <div class="intro-container">
                <!-- Immagine Profilo -->
                <figure>
                    <img src="foto_profilo_cv_padded-photoaidcom-cropped.jpg" alt="Marco Santamaria" />
                </figure>

                <!-- Divisore tra immagine e testo -->
                <hr>
                

                <!-- Testo Introduzione -->
                <div>
                    <hgroup>
                        <h2>Greetings</h2>
                        <h3>My name is Marco Santamaria, and I specialize in analyzing financial data with a passion for economics and information technology.</h3>
                    </hgroup>
                    <p>
                        Beyond my academic background, I've consistently challenged myself by creating programs to aid financial analysis, streamline information gathering, and improve efficiency. My design approach has never been limited solely to computing; sometimes, thinking outside the box is essential. This perspective led me to develop entrepreneurial projects, which allowed me to develop critical soft skills such as team management, supplier sourcing, creativity and problem-solving abilities.
                    </p>
                </div>
            </div>

            <!-- Sezione dei Progetti -->
            <h3>MY PROJECTS</h3>
            <ul>
                <li><!-- Sezione per il Download del PDF -->
                    <h4>Research: "Competition Between Companies: The Volkswagen Case"</h4>
                    <p>In this research, I highlighted the current and future challenges that Volkswagen will need to overcome to maintain its position in the automotive market.</p>
                    <button class="download-btn" onclick="window.location.href='Ricerca Volkswagen.pdf';">
                        üìÑ Download PDF
                    </button>
                </li>
                <div style="height: 50px;"></div> <!-- Spazio tra i progetti -->
                <li>
                    <h4>Project 1: Financial Data Analysis of Listed Companies</h4>
                    <p>I developed a financial data analysis adaptable to any publicly listed company, using tools such as Python to forecast future trends and enhance investment strategies.</p>
                    <pre id="code1"><code class="language-python">
import yfinance as yf
import pandas as pd
import csv
import matplotlib.pyplot as plt
import numpy as np
from scipy.stats import norm
from pandas.plotting import scatter_matrix
import statsmodels.formula.api as smf
import warnings
import datetime as dt
import warnings
warnings.filterwarnings("ignore")
pd.set_option('display.max_rows', None)  # Mostra tutte le righe
pd.set_option('display.max_columns', None)  # Mostra tutte le colonne
pd.set_option('display.width', None)  # Per evitare la riduzione del testo
pd.set_option('display.max_colwidth', None)  # Per evitare l'abbattimento del testo delle celle

ticker = 'NVDA'  # Impostiamo il ticker per l'azione che vogliamo analizzare, in questo caso Nvidia

# Data corrente
oggi = dt.datetime.today()  # Otteniamo la data di oggi
# Verifica se siamo al 31 gennaio o successivamente nell'anno corrente
if oggi >= dt.datetime(oggi.year, 1, 31):  # Se la data odierna √® uguale o successiva al 31 gennaio
    ultimo_anno = dt.datetime(oggi.year, 2, 1)  # Impostiamo il 1¬∞ febbraio dell'anno corrente
else:
    ultimo_anno = dt.datetime(oggi.year-1, 2, 1)  # Altrimenti, mettiamo il 1¬∞ febbraio dell'anno precedente
print(ultimo_anno)

# Calcola la data di inizio come 31 gennaio di 5 anni fa
primo_anno = ultimo_anno - dt.timedelta(days=5*365)  # Sottrai 5 anni da "ultimo_anno" per avere il punto di inizio
start_date = primo_anno.strftime('%Y-%m-%d')  # Formatta la data di inizio in formato 'yyyy-mm-dd'
end_date = ultimo_anno.strftime('%Y-%m-%d')  # Formatta la data di fine in formato 'yyyy-mm-dd'

print("Start Date:", start_date)
print("End Date:", end_date)

# Scarica i dati giornalieri di NVDA (Nvidia) per l'intervallo di date appena definito
fb = yf.download(ticker, start=start_date, end=end_date, interval="1d")  # Scarica i dati giornalieri

# Aggiunge la colonna Date per filtrare i dati facilmente
fb['Date'] = fb.index

# Funzione per ottenere il prezzo di chiusura del 31 gennaio (o il giorno pi√π vicino) di ogni anno
def get_close_price_for_january_31(x):
    # Cerca il 31 gennaio nel DataFrame
    gennaio_31 = x[(x['Date'].dt.month == 1) & (x['Date'].dt.day == 31)]
    if not gennaio_31.empty:
        return gennaio_31.iloc[0]  # Se trova il 31 gennaio, restituisce il primo valore trovato
    else:
        # Se il 31 gennaio non √® presente, cerca il giorno precedente
        for i in range(1, 32):  # Cerchiamo fino a 31 giorni precedenti
            giorno_precedente = x[x['Date'].dt.month == 1][x['Date'].dt.day == (31 - i)]
            if not giorno_precedente.empty:
                return giorno_precedente.iloc[0]  # Restituisce il primo giorno trovato
        return None  # Se non trova nulla, restituisce None

# Applica la funzione a ogni gruppo annuale
gennaio_31_per_anno = fb.groupby(fb['Date'].dt.year).apply(get_close_price_for_january_31)
# Rimuove eventuali valori nulli (None)
gennaio_31_per_anno = gennaio_31_per_anno.dropna()

# Converte l'indice degli anni in un formato numerico
gennaio_31_per_anno.index = gennaio_31_per_anno.index.astype(int)

# Scarica i dati finanziari dell'azienda
azienda = yf.Ticker(ticker)
# Bilancio e conto economico dell'azienda
cont_ec = azienda.financials  # Conto economico (entrate, profitti, ecc.)
bilancio = azienda.balance_sheet  # Bilancio (attivit√†, passivit√†, capitale proprio)
rend_fin = azienda.cash_flow  # Flussi di cassa
dividendi = azienda.dividends  # Dividendi pagati

# Otteniamo il prezzo corrente dell'azione
prezzo_corrente = azienda.history(period="1d")

# Visualizziamo i dati finanziari
print('CONTO ECONOMICO\n', cont_ec,'\n')
print('BILANCIO\n', bilancio,'\n')
print('RENDICONTO FINANZIARIO\n', rend_fin,'\n')
print('PREZZO DI OGGI\n', prezzo_corrente,'\n')

# Calcolo di vari indici finanziari

# Ricavi
ricavi = cont_ec.loc['Total Revenue']
# Ordina i dati in ordine crescente per anno
ricavi = ricavi.sort_index()
# Utile netto
utile_netto = cont_ec.loc['Net Income']
# Margine lordo (Gross Profit / Total Revenue) - Percentuale
margine_lordo = (cont_ec.loc['Gross Profit'] / ricavi) * 100
# Utile operativo (Operating Income)
utile_operativo = cont_ec.loc['Operating Income']

# Crescita dei ricavi: calcoliamo la variazione percentuale anno su anno dei ricavi
crescita_ricavi = ricavi.pct_change().apply(lambda x: f"{x * 100:.2f}%" if pd.notnull(x) else "N/A")
print("\nCrescita Ricavi:")
print(crescita_ricavi)

# Margine lordo: Esprimiamo come percentuale
margine_lordo_formattato = margine_lordo.apply(lambda x: f"{x:.2f}%" if pd.notnull(x) else "N/A")
print("\nMargine Lordo:")
print(margine_lordo_formattato)

#i dati possono differire da internet dato che solitamente
#  si usano i dati TTM che sono pi√π attuali e non quelli annuali

# ROE (Return on Equity): ritorno sugli investimenti degli azionisti
capitale_proprio = bilancio.loc['Common Stock Equity']
roe = (utile_netto / capitale_proprio) * 100  # Formula base: utile netto / capitale proprio

# ROA (Return on Assets): ritorno sugli attivi totali
totale_attivo = bilancio.loc['Total Assets']
roa = (utile_netto / totale_attivo) * 100  # Formula base: utile netto / totale attivo

# ROS (Return on Sales): ritorno sulle vendite
ros = (utile_operativo / ricavi) * 100  # Formula base: utile operativo / ricavi

# ROD (Return on Debt): ritorno sul debito
interessi_passivi = cont_ec.loc['Interest Expense']  # Interessi sul debito
interessi_passivi = interessi_passivi.sort_index()
debito_totale = bilancio.loc['Total Liabilities Net Minority Interest']  # Debito totale
debito_totale = debito_totale.sort_index()
rod = (interessi_passivi / debito_totale) * 100  # Formula base: interessi passivi / debito totale

# Tasso di indebitamento: misura del debito rispetto agli attivi totali
tasso_indebitamento = debito_totale / totale_attivo

# Current Ratio: misura la capacit√† di un'azienda di coprire le proprie passivit√† correnti con le attivit√† correnti
attivit√†_correnti = bilancio.loc['Current Assets']
attivit√†_correnti=attivit√†_correnti.sort_index()
passivit√†_correnti = bilancio.loc['Current Liabilities']
passivit√†_correnti=passivit√†_correnti.sort_index()
current_ratio = attivit√†_correnti / passivit√†_correnti

# Quick Ratio: simile al Current Ratio ma esclude le rimanenze (magazzino)
try:
    rimanenze = bilancio.loc['Inventory']  # Cerca la voce rimanenze
    rimanenze = rimanenze.sort_index()
except KeyError:
    rimanenze = pd.Series(data=["N/A"] * bilancio.shape[1], index=bilancio.columns)  # Se non c'√®, usa "N/A"
    print("\nAttenzione: La voce 'Inventory' non √® presente nei dati.")

quick_ratio = (attivit√†_correnti - rimanenze) / passivit√†_correnti

# ROIC (Return on Invested Capital): ritorno sul capitale investito, utile operativo al netto delle imposte
nopat = utile_operativo * (1 - 0.22)  # Supponendo un'aliquota fiscale del 22%
capitale_investito = capitale_proprio + debito_totale  # Capitale investito √® capitale proprio + debito
roic = (nopat / capitale_investito) * 100  # Formula base: NOPAT / Capitale investito

# Prezzo per azione al 31 gennaio di ogni anno
prezzo_per_azione = gennaio_31_per_anno['Close'].squeeze()

# EPS (Earnings Per Share): utile per azione
eps = utile_netto / bilancio.loc['Ordinary Shares Number']
eps.index = eps.index.year  # Impostiamo l'indice degli anni
#serve per modificare l‚Äôindice del DataFrame eps in modo che
# contenga solo l‚Äôanno, invece di avere una data completa

# P/E (Price-to-Earnings): rapporto tra prezzo per azione e EPS
pe_ratio = prezzo_per_azione / eps

# Ricavi per azione
ricavi_per_azione = ricavi / bilancio.loc['Ordinary Shares Number']
ricavi_per_azione.index = ricavi_per_azione.index.year

# P/S (Price-to-Sales): rapporto tra prezzo per azione e ricavi per azione
ps_ratio = prezzo_per_azione / ricavi_per_azione

# Valore contabile per azione: valore netto del patrimonio per azione
valore_contabile_per_azione = capitale_proprio / bilancio.loc['Ordinary Shares Number']
valore_contabile_per_azione.index = valore_contabile_per_azione.index.year

# P/B (Price-to-Book): rapporto tra prezzo per azione e valore contabile per azione
pb_ratio = prezzo_per_azione / valore_contabile_per_azione

# Free Cash Flow per azione: flusso di cassa operativo netto per azione
free_cash_flow = rend_fin.loc['Cash Flow From Continuing Operating Activities'] - rend_fin.loc['Capital Expenditure']
fcf_per_azione = free_cash_flow / bilancio.loc['Ordinary Shares Number']
fcf_per_azione.index = fcf_per_azione.index.year

# P/FCF (Price-to-Free Cash Flow): rapporto tra prezzo per azione e flusso di cassa libero per azione
pfcf_ratio = prezzo_per_azione / fcf_per_azione

# Stampa dei risultati
print("\nROE (Return on Equity):\n", roe.apply(lambda x: f"{x:.2f}%" if pd.notnull(x) else "N/A"))
print("\nROA (Return on Assets):\n", roa.apply(lambda x: f"{x:.2f}%" if pd.notnull(x) else "N/A"))
print("\nROS (Return on Sales):\n", ros.apply(lambda x: f"{x:.2f}%" if pd.notnull(x) else "N/A"))
print("\nROD (Return on Debt):\n", rod.apply(lambda x: f"{x:.2f}%" if pd.notnull(x) else "N/A"))
print("\nTasso di Indebitamento:\n", tasso_indebitamento.apply(lambda x: f"{x:.2f}" if pd.notnull(x) else "N/A"))
print("\nCurrent Ratio:\n", current_ratio.apply(lambda x: f"{x:.2f}" if pd.notnull(x) else "N/A"))
print("\nQuick Ratio:\n", quick_ratio.apply(lambda x: f"{x:.2f}" if pd.notnull(x) else "N/A"))
print("\nROIC (Return on Invested Capital)\n:", roic.apply(lambda x: f"{x:.2f}%" if pd.notnull(x) else "N/A"))
print("\nPE ratio:\n", pe_ratio.apply(lambda x: f"{x:.2f}" if pd.notnull(x) else "N/A"))
print("\nPS ratio:\n", ps_ratio.apply(lambda x: f"{x:.2f}" if pd.notnull(x) else "N/A"))
print("\nPB ratio:\n", pb_ratio.apply(lambda x: f"{x:.2f}" if pd.notnull(x) else "N/A"))
print("\nPFCF ratio:\n", pfcf_ratio.apply(lambda x: f"{x:.2f}" if pd.notnull(x) else "N/A"))

                    </code></pre>
                    <button class="copy-btn" onclick="copyCode('code1')">Copia Codice</button>
                </li>
                <div style="height: 50px;"></div> <!-- Spazio tra i progetti -->
                <li>
                    <h4>Project 2: Staying Updated in the Financial World</h4>
                    <p>I developed a program that allows me to receive Telegram messages with financial news about designated companies through my own AWS server.</p>
                    <pre id="code2"><code class="language-python">
import finnhub
from datetime import datetime, timedelta, timezone
import os
import requests
from difflib import SequenceMatcher

# Impostazioni API
FINNHUB_API_KEY = os.getenv("FINNHUB_API_KEY")
TELEGRAM_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
STOCK_SYMBOL = ['AAPL']
CHAT_ID = os.getenv("CHAT_ID")


# Inizializza il client Finnhub
finnhub_client = finnhub.Client(api_key=FINNHUB_API_KEY)

# Lista per tracciare i titoli delle notizie gi√† inviati
sent_news_titles = []

# Funzione per ottenere le ultime notizie sull'azione tramite Finnhub
def fetch_latest_news(stock_symbol, from_date, to_date):
try:
    news = finnhub_client.company_news(stock_symbol, _from=from_date, to=to_date)
    return news
except Exception as e:
    print(f"Errore nel recupero delle notizie per {stock_symbol}: {e}")
    return []

# Funzione per inviare messaggi su Telegram utilizzando l'API HTTP
def send_telegram_message(message):
url = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendMessage"
params = {
    "chat_id": CHAT_ID,
    "text": message,
}
response = requests.get(url, params=params)
if response.status_code == 200:
    print(f"Messaggio inviato: {message}")
else:
    print(f"Errore nell'invio del messaggio: {response.text}")

# Funzione per confrontare due titoli con una soglia di somiglianza
def is_similar(title1, title2, threshold=0.8):
similarity = SequenceMatcher(None, title1, title2).ratio()
return similarity >= threshold

# Funzione principale
def lambda_handler(event, context):
try:
    # Calcola le date di oggi e ieri
    yesterday = (datetime.now() - timedelta(days=1)).date().strftime("%Y-%m-%d")
    today = datetime.now().date().strftime("%Y-%m-%d")

    global sent_news_titles  # Usa la lista globale per tracciare i titoli inviati

    for symbol in STOCK_SYMBOL:
        # Recupera le notizie di ieri
        yesterday_news = fetch_latest_news(symbol, from_date=yesterday, to_date=yesterday)
        # Recupera le notizie di oggi
        today_news = fetch_latest_news(symbol, from_date=today, to_date=today)

        # Combina le notizie di ieri e oggi
        combined_news = yesterday_news + today_news

        if not combined_news:
            # Se non ci sono notizie, invia un messaggio su Telegram
            send_telegram_message(f"Nessuna notizia trovata per il titolo {symbol}.")
        else:
            for news in combined_news:
                news_title = news['headline']  # Usa il titolo della notizia
                news_date = datetime.fromtimestamp(news['datetime'], tz=timezone.utc).date()

                # Controlla se la notizia √® gi√† stata inviata in base al titolo
                already_sent = any(is_similar(news_title, sent_title) for sent_title in sent_news_titles)

                if not already_sent and (news_date == datetime.now().date() or news_date == (datetime.now() - timedelta(days=1)).date()):
                    # Aggiungi il titolo alla lista delle notizie inviate
                    sent_news_titles.append(news_title)
                    message = f"- {news_title}\n{news['url']}"
                    send_telegram_message(message)

except Exception as e:
    print(f"Errore generale: {e}")

                    </code></pre>
                    <button class="copy-btn" onclick="copyCode('code2')">Copia Codice</button>
                </li>
                <div style="height: 50px;"></div> <!-- Spazio tra i progetti -->
                <li>
                    <h4>Project 3: Statistical Analysis with Stock Price Charts</h4>
                    <p>This project included building predictive models aimed at gaining a statistical advantage in forecasting stock price movements.</p>
                    <pre id="code3"><code class="language-python">
import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.linear_model import LinearRegression
from datetime import datetime, timedelta
import warnings
warnings.filterwarnings("ignore")
import requests
from statsmodels.tsa.seasonal import seasonal_decompose
# Imposta il ticker del titolo principale
ticker = 'AAPL'

# Definisci l'intervallo di date
start_date = '2019-01-31'
end_date = '2024-01-31'

# Scarica i dati del titolo principale
df = yf.download(ticker, start=start_date, end=end_date)
print(df.shape)
# Funzione per trovare i concorrenti tramite l'API Finnhub
def trova_concorrenti_finhub(ticker, api_key):
    """Ottiene i concorrenti di un'azienda utilizzando FinHub API e li restituisce in una lista"""
    url = f"https://finnhub.io/api/v1/stock/peers?symbol={ticker}&token={api_key}"
    
    response = requests.get(url)

    if response.status_code == 200:
        data = response.json()
        if data:
            concorrenti = data  # Salva i concorrenti in una lista
            return concorrenti
        else:
            print("Nessun concorrente trovato.")
            return []
    else:
        print("Errore nella richiesta:", response.status_code, response.text)
        return []

# Funzione per scaricare i dati dei titoli
def scarica_dati(tickers, start_date, end_date):
    """Scarica i dati di chiusura di pi√π titoli azionari usando yfinance"""
    data = yf.download(tickers, start=start_date, end=end_date)['Close']
    return data

# ESECUZIONE
api_key = input("Inserisci la tua chiave API di Finnhub: ")

ticker = "AAPL"  # Cambia con il ticker desiderato

# Trova i concorrenti tramite l'API
competitor_tickers = trova_concorrenti_finhub(ticker, api_key)

# Verifica se la lista dei concorrenti √® valida
if competitor_tickers:
    print("\nConcorrenti trovati:")
    for competitor in competitor_tickers:
        print(competitor)

    # Aggiungi il ticker del titolo principale alla lista dei concorrenti
    competitor_tickers.append(ticker)

    # Definisci l'intervallo di date
    start_date = '2019-01-01'
    end_date = '2024-01-01'

    # Scarica i dati di chiusura dei titoli
    competitor_data = scarica_dati(competitor_tickers, start_date, end_date)

    # Calcola la matrice di correlazione
    correlation_matrix = competitor_data.corr()

    # Grafico della matrice di correlazione
    plt.figure(figsize=(10, 8))
    sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt='.2f')
    plt.title('Matrice di Correlazione dei Prezzi di Chiusura')
    plt.show()

else:
    print("Impossibile procedere con l'analisi senza concorrenti.")

df['Close'] = df['Close'].squeeze()  # Assicura che sia unidimensionale

# Regressione lineare sul prezzo
df = df.dropna()
X = np.arange(len(df)).reshape(-1, 1)
y = df['Close'].values
model = LinearRegression().fit(X, y)
df['Trend'] = model.predict(X)

# Calcola le medie mobili
df['MA20'] = df['Close'].rolling(window=20).mean()
df['MA50'] = df['Close'].rolling(window=50).mean()
df['MA200'] = df['Close'].rolling(window=200).mean()

# Formula della retta di regressione
slope = model.coef_[0]
intercept = model.intercept_
print("Formula della retta di regressione: y = " + str(round(float(slope), 2)) + "x + " + str(round(float(intercept), 2)))


# Strategie di trading
def apply_strategy(signal_col):
    df[f'Daily_Return_{signal_col}'] = df['Close'].pct_change()
    df[f'Strategy_Return_{signal_col}'] = df[signal_col].shift(1) * df[f'Daily_Return_{signal_col}']
    df[f'Portfolio_Value_{signal_col}'] = 100 * (1 + df[f'Strategy_Return_{signal_col}']).cumprod()
 # Calcola il rendimento percentuale sui 100‚Ç¨ investiti con una semplice divisione
    df[f'Percent_Return_{signal_col}'] = df[f'Portfolio_Value_{signal_col}'] / 100 * 100 - 100

# Medie Mobili
df['Signal_MA'] = np.where(df['MA20'] > df['MA50'], 1, -1)
apply_strategy('Signal_MA')

# RSI
delta = df['Close'].diff()
gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
rs = gain / loss
df['RSI'] = 100 - (100 / (1 + rs))
df['Signal_RSI'] = np.where(df['RSI'] < 30, 1, np.where(df['RSI'] > 70, -1, 0))
apply_strategy('Signal_RSI')

# MACD
df['EMA12'] = df['Close'].ewm(span=12, adjust=False).mean()
df['EMA26'] = df['Close'].ewm(span=26, adjust=False).mean()
df['MACD'] = df['EMA12'] - df['EMA26']
df['Signal_Line'] = df['MACD'].ewm(span=9, adjust=False).mean()
df['Signal_MACD'] = np.where(df['MACD'] > df['Signal_Line'], 1, -1)
apply_strategy('Signal_MACD')



# Golden Cross
df['Signal_GoldenCross'] = np.where(df['MA50'] > df['MA200'], 1, -1)
apply_strategy('Signal_GoldenCross')

# Grafico comparativo
plt.figure(figsize=(14, 7))
strategies = ['MA', 'RSI', 'MACD', 'GoldenCross']
for strat in strategies:
    plt.plot(df.index, df[f'Portfolio_Value_Signal_{strat}'], label=strat)
plt.title(f'Backtest Strategie di Trading su {ticker}')
plt.xlabel('Data')
plt.ylabel('Valore del Portafoglio (‚Ç¨)')
plt.legend()
plt.show()



# Ranking delle performance
performance = {}
for strat in strategies:
    final_value = df[f'Portfolio_Value_Signal_{strat}'].iloc[-1]
    percent_return = df[f'Percent_Return_Signal_{strat}'].iloc[-1]
    daily_returns = df[f'Strategy_Return_Signal_{strat}'].dropna()
    sharpe_ratio = daily_returns.mean() / daily_returns.std() * np.sqrt(252)
    max_drawdown = (df[f'Portfolio_Value_Signal_{strat}'] / df[f'Portfolio_Value_Signal_{strat}'].cummax() - 1).min()
    performance[strat] = {'Final Value': final_value, 'Percent Return': percent_return, 'Sharpe Ratio': sharpe_ratio, 'Max Drawdown': max_drawdown}

performance_df = pd.DataFrame(performance).T.sort_values(by='Final Value', ascending=False)
print(performance_df)


# Raggruppa per mese e calcola la media (frequenza mensile)
df_monthly = df['Close'].resample('M').mean()

# Decomposizione stagionale (modello additivo, periodo annuale)
result = seasonal_decompose(df_monthly, model='additive', period=12)

# Estrai il componente stagionale
seasonal = result.seasonal

# Crea un grafico con i mesi come linea del tempo
plt.figure(figsize=(10, 6))
seasonal.plot()
plt.title('Componente Stagionale del Prezzo di Chiusura (con Mesi come Linea del Tempo)', fontsize=16)
plt.xlabel('Mese', fontsize=12)
plt.ylabel('Componente Stagionale', fontsize=12)
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

                    </code></pre>
                    <button class="copy-btn" onclick="copyCode('code3')">Copia Codice</button>
                </li>
            </ul>
        </section>
    </main>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script>
        function copyCode(codeId) {
            const codeElement = document.getElementById(codeId);
            const range = document.createRange();
            range.selectNode(codeElement);
            window.getSelection().addRange(range);
            document.execCommand('copy');
            window.getSelection().removeAllRanges();
            alert('Codice copiato negli appunti!');
        }
    </script>
    <script src="https://platform.linkedin.com/badges/js/profile.js" async defer type="text/javascript"></script>
</body>
</html>
